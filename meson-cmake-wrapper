#!/usr/bin/env python3
import json
import pickle
import socket
import logging
import logging.config
import xml.etree.ElementTree as ETree
import filecmp
import hashlib
import os
from shutil import copy, copytree, rmtree
from pathlib import Path
from subprocess import call, Popen, PIPE, DEVNULL
from sys import argv, stderr
from time import sleep

SERVER_HEADER = b'\n[== "CMake Server" ==[\n'
SERVER_FOOTER = b'\n]== "CMake Server" ==]\n'


def debug_connect():
    connected = False
    while not connected:
        try:
            import socket
            server = socket.socket(proto=socket.IPPROTO_TCP)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind(('127.0.0.1', 3018))
            server.close()
            connected = True
        except OSError:
            import time
            time.sleep(1)

    import ptvsd
    ptvsd.enable_attach('SECRET', ('127.0.0.1', 3018))
    ptvsd.wait_for_attach()
    return True


class CMakeWrapper:
    """
    Class that emulates CMake commands and translates them to the equivalent in Meson.
    """

    def __init__(self):
        self.version = [3, 10, 0]
        self.path = argv[0]
        self.debug = False
        self.command = 'generate'
        self.generator = None
        self.build_type = None
        self.cache_entries = {}
        self.target = 'all'
        self.target_args = []
        self.build_dir = None
        self.source_dir = None
        self.meson = Meson()
        if os.name == 'nt':
            self.server = NamedPipeServer(self)
        else:
            self.server = UnixSocketServer(self)
        self.tool = CommandToolWrapper(self)
        self.logger = None

    def run(self, args):
        self.log('(argv) "%s"' % argv)
        self.log('(cwd) "%s"' % os.getcwd())

        self.parse_args(args)

        # debug_connect()

        # Unknown command
        if not hasattr(self, self.command + '_cmd'):
            self.help_cmd()
            return

        # Run command
        try:
            getattr(self, self.command + '_cmd')()
        except Exception as e:
            self.log(e)
            raise e
        finally:
            self.save_cache_entries()

    def parse_args(self, args):
        if len(args) == 1:
            self.command = 'none'
        i = 1
        while i < len(args):
            if args[i] == '-version' or args[i] == '--version':
                self.command = 'version'
            elif args[i] == '-help' or args[i] == '--help':
                self.command = 'help'
            elif args[i] == '--debug-output':
                self.debug = True
            # Undocumented CMake flags -H -B
            elif args[i].startswith('-H'): 
                self.set_source_dir(args[i][2:])
            elif args[i].startswith('-B'): 
                self.set_build_dir(args[i][2:])
            elif args[i] == '-G':
                self.command = 'generate'
                i += 1
                self.set_generator(args[i])
            elif args[i].startswith('-G'):
                self.command = 'generate'
                self.set_generator(args[i][2:])
            elif args[i] == '--build':
                self.command = 'build'
                i += 1
                self.set_build_dir(args[i])
            elif args[i] == '--target':
                i += 1
                self.target = args[i]
            elif args[i] == '--config':
                i += 1
                self.set_build_type(args[i])
            elif args[i] == '--':
                self.target_args = args[i + 1:]
                break
            elif args[i] == '-E':
                self.command = 'tool'
                self.command_args = args[i + 1:]
                break
            elif args[i].startswith('-D'):
                self.parse_cache_entry(args[i])
            else:
                self.set_source_dir(args[i])
            i += 1

    def none_cmd(self):
        print('Usage\n')
        print('  meson-cmake-wrapper [options] <path-to-source>')
        print('  meson-cmake-wrapper [options] <path-to-existing-build>\n')
        print('Specify a source directory to (re-)generate a build system for it in the')
        print('current working directory.  Specify an existing build directory to')
        print('re-generate its build system.\n')
        print('Run \'meson-cmake-wrapper --help\' for more information.\n')

    def version_cmd(self):
        print('cmake version {0}'.format('.'.join(map(str, self.version))))

    def help_cmd(self):
        print('Usage\n')
        print('meson-cmake-wrapper [options] <path-to-source>')
        print('meson-cmake-wrapper [options] <path-to-existing-build>\n')
        print('Specify a source directory to (re-)generate a build system for it in the')
        print('current working directory.  Specify an existing build directory to')
        print('re-generate its build system.\n')
        print('Options')
        print('  -C <initial-cache>           = Pre-load a script to populate the cache.')
        print('  -D <var>[:<type>]=<value>    = Create a cmake cache entry.')
        print('  -G <generator-name>          = Specify a build system generator.')
        print('  -E                           = CMake command mode.\n')
        print('  --build <dir>                = Build a CMake-generated project binary tree.')
        print('  --version,-version,/V [<f>]  = Print version number and exit.')
        print('  --debug-output               = Put cmake in a debug mode.\n')
        print('Generators\n')
        print('The following generators are available on this platform:')
        print('  Unix Makefiles               = Generates standard UNIX makefiles.')
        print('  Ninja                        = Generates build.ninja files.')
        print('  CodeBlocks - Ninja           = Generates CodeBlocks project files.\n')
        print('  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.\n')

    def generate_cmd(self):
        # Set default build dir
        if not self.build_dir:
            self.set_build_dir(os.getcwd())

        print('Generate to build directory: ' + self.build_dir)

        # Set default generator
        if not self.generator:
            self.set_generator('Unix Makefiles')

        # Make sure meson is setup
        if not self.meson.setup():
            return

        # Create CMakeCache.txt
        self.gen_cmake_cache()

        if self.generator.endswith('Unix Makefiles'):
            self.gen_make_project()

        if self.generator.startswith('CodeBlocks'):
            self.gen_codeblocks_project()

    def build_cmd(self):
        print('Building target: ' + self.target)

        # Set default build dir
        if not self.build_dir:
            self.set_build_dir(os.getcwd())

        self.load_cache_entries()

        self.meson.build(self.target)

    def tool_cmd(self):
        self.tool.run(self.command_args)

    def init_logging(self):
        # Setup loggers
        loggers = []
        self.logger = logging.getLogger('CMake Wrapper')
        loggers.append(self.logger)
        self.meson.logger = logging.getLogger('Meson')
        loggers.append(self.meson.logger)
        self.server.logger = logging.getLogger('Server')
        loggers.append(self.server.logger)

        # Cleanup if reinitialized
        for logger in loggers:
            logger.handlers = []

        # Setup handlers and formatters
        handlers = []
        handler = logging.FileHandler(os.path.join(self.build_dir, 'meson-cmake-wrapper.log'))
        handler.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s: %(message)s')
        handler.setFormatter(formatter)
        handlers.append(handler)

        if self.debug:
            handler = logging.StreamHandler(stderr)
            handler.setLevel(logging.INFO)
            formatter = logging.Formatter('%(name)s: %(message)s')
            handler.setFormatter(formatter)
            handlers.append(handler)

            handler = ServerLogHandler(self.server)
            handler.setLevel(logging.INFO)
            formatter = logging.Formatter('%(name)s: %(message)s')
            handler.setFormatter(formatter)
            handlers.append(handler)

        for logger in loggers:
            logger.setLevel(logging.INFO)
            for handler in handlers:
                logger.addHandler(handler)

    def log(self, msg):
        if not self.logger:
            return
        if isinstance(msg, Exception):
            self.logger.info(msg, exc_info=msg)
        else:
            self.logger.info(msg)

    def set_generator(self, generator):
        if generator == 'Ninja':
            self.meson.set_backend('ninja')
        elif generator == 'Unix Makefiles':
            self.meson.set_backend('ninja')
        elif generator == 'CodeBlocks - Ninja':
            self.meson.set_backend('ninja')
        elif generator == 'CodeBlocks - Unix Makefiles':
            self.meson.set_backend('ninja')
        else:
            raise Exception('Generator not supported: ' + generator)
        self.generator = generator

        self.log('(generator) "%s"' % self.generator)

    def set_source_dir(self, source_dir):
        self.source_dir = os.path.abspath(source_dir)
        self.meson.source_dir = self.source_dir

        self.log('(source_dir) "%s"' % self.source_dir)

    def set_build_dir(self, build_dir):
        self.build_dir = os.path.abspath(build_dir)
        self.meson.build_dir = self.build_dir
        self.init_logging()

        # Handle cmake_test_run (CLion)
        if self.source_dir:
            cmake_file = os.path.join(self.source_dir, 'CMakeLists.txt')
            meson_file = os.path.join(self.source_dir, 'meson.build')
            if not os.path.exists(meson_file) and os.path.getsize(cmake_file) > 0:
                with open(meson_file, 'w') as file:
                    file.write('project(\'empty\')')

        self.load_cache_entries()
        
        self.log('(build_dir) "%s"' % self.build_dir)

    def set_build_type(self, build_type):
        self.build_type = build_type
        if build_type.upper() in ('DEBUG', ''):
            self.meson.build_type = 'debug'
        elif build_type.upper() == 'RELEASE':
            self.meson.build_type = 'release'
        elif build_type.upper() == 'RELWITHDEBINFO':
            self.meson.build_type = 'debugoptimized'
        elif build_type.upper() == 'MINSIZEREL':
            self.meson.build_type = 'minsize'
        else:
            self.meson.build_type = 'plain'

        self.log('(build_type) "%s"' % self.build_type)

    def init_cache_entries(self):
        if not self.source_dir:
            raise Exception('Source dir not provided')
        self.meson.setup()

        cache_entries = {
            'CMAKE_EXPORT_COMPILE_COMMANDS': ('YES', 'BOOL'),
            'CMAKE_INSTALL_PREFIX': ('/usr/local', 'PATH'),
            'CMAKE_PROJECT_NAME': (self.meson.get_project_info()['name'], 'STATIC'),
            '%s_BINARY_DIR' % self.meson.get_project_info()['name']: (self.build_dir, 'STATIC'),
            '%s_SOURCE_DIR' % self.meson.get_project_info()['name']: (self.source_dir, 'STATIC'),
            'CMAKE_CACHEFILE_DIR': (self.build_dir, 'INTERNAL'),
            'CMAKE_CACHE_MAJOR_VERSION': (str(self.version[0]), 'INTERNAL'),
            'CMAKE_CACHE_MINOR_VERSION': (str(self.version[1]), 'INTERNAL'),
            'CMAKE_CACHE_PATCH_VERSION': (str(self.version[2]), 'INTERNAL'),
            'CMAKE_COMMAND': (argv[0], 'INTERNAL'),
            'CMAKE_GENERATOR': (self.generator, 'INTERNAL'),
            'CMAKE_HOME_DIRECTORY': (self.source_dir, 'INTERNAL'),
            'CMAKE_ROOT': (os.path.dirname(self.path), 'INTERNAL'),
        }

        for key, val in self.cache_entries.items():
            cache_entries[key] = val
        self.cache_entries = cache_entries

    def parse_cache_entry(self, entry):
        if ':' in entry:
            key, rest = entry[2:].split(':', 1)
            ty, val = rest.split('=', 1)
        else:
            key, val = entry[2:].split('=', 1)
            ty = 'STRING'
        self.cache_entries[key] = (val, ty, '')
        self.update_cache_entry(key, val)

    def update_cache_entry(self, key, val):
        if key == 'CMAKE_GENERATOR':
            self.set_generator(val)
        elif key == 'CMAKE_BUILD_TYPE':
            self.set_build_type(val)
        elif key == 'CMAKE_HOME_DIRECTORY':
            self.set_source_dir(val)
        elif key == 'CMAKE_C_COMPILER':
            os.environ['CC'] = val
        elif key == 'CMAKE_CXX_COMPILER':
            os.environ['CXX'] = val
        elif key == 'CMAKE_C_FLAGS':
            os.environ['CFLAGS'] = val
        elif key == 'CMAKE_CXX_FLAGS':
            os.environ['CXXFLAGS'] = val
        # Use CMake variable 'MESON' for custom Meson path
        elif key == 'MESON':
            self.meson.path = val
        # Use CMake variable 'CROSS_FILE' for setting Meson cross-file
        elif key == 'CROSS_FILE':
            self.meson.cross_file = val

    def save_cache_entries(self):
        if self.build_dir:
            cache_file = os.path.join(self.build_dir, 'cmake-cache.pk1')
            with open(cache_file, 'wb') as output:
                pickle.dump(self.cache_entries, output, pickle.HIGHEST_PROTOCOL)

    def load_cache_entries(self):
        cache_file = os.path.join(self.build_dir, 'cmake-cache.pk1')
        if os.path.exists(cache_file):
            with open(cache_file, 'rb') as input:
                loaded_entries = pickle.load(input)
                diff_entries = set(loaded_entries) - set(self.cache_entries)

                for key in diff_entries:
                    self.cache_entries[key] = loaded_entries[key]
                    self.update_cache_entry(key, loaded_entries[key][0])
        elif self.source_dir:
            self.init_cache_entries()

    def gen_cmake_cache(self):
        with open(os.path.join(self.build_dir, 'CMakeCache.txt'), 'w') as file:
            file.write('# Generated by meson-cmake-wrapper\n\n')
            file.write('########################\n')
            file.write('# Cache entries\n')
            file.write('########################\n\n')
            for entry in self.cache_entries.items():
                file.write('%s:%s=%s\n' % (entry[0], entry[1][1], entry[1][0]))

    def gen_codeblocks_project(self):
        root = ETree.Element('CodeBlocks_project_file')
        tree = ETree.ElementTree(root)
        ETree.SubElement(root, 'FileVersion', {'major': '1', 'minor': '6'})
        project = ETree.SubElement(root, 'Project')
        ETree.SubElement(project, 'Option', {'title': self.meson.get_project_info()['name']})
        ETree.SubElement(project, 'Option', {'makefile_is_custom': '1'})
        ETree.SubElement(project, 'Option', {'compiler': 'gcc'})
        ETree.SubElement(project, 'Option', {'virtualFolders': 'Meson Files'})

        build = ETree.SubElement(project, 'Build')

        all_target = {
            'name': 'all',
            'id': 'all',
            'type': 'custom',
            'filename': ''
        }

        for target in  [all_target] + self.meson.get_targets():
            build_target = ETree.SubElement(build, 'Target', {'title': target['name']})
            output = os.path.join(self.meson.build_dir, target['filename'])
            output_dir = os.path.split(output)[0]
            ETree.SubElement(build_target, 'Option', {'output': output})
            ETree.SubElement(build_target, 'Option', {'working_dir': output_dir})
            ETree.SubElement(build_target, 'Option', {'object_output': os.path.join(output_dir, target['id'])})
            ty = {
                'executable': '1',
                'static library': '2',
                'shared library': '3',
                'custom': '4'
            }[target['type']]
            ETree.SubElement(build_target, 'Option', {'type': ty})

            compiler = self.meson.get_compiler(target)
            if compiler:
                ETree.SubElement(build_target, 'Option', {'compiler': 'gcc'})

            compiler = ETree.SubElement(build_target, 'Compiler')
            for define in self.meson.get_defines(target):
                ETree.SubElement(compiler, 'Add', {'option': define})
            for include_dir in self.meson.get_include_directories(target):
                ETree.SubElement(compiler, 'Add', {'directory': include_dir})

            make_commands = ETree.SubElement(build_target, 'MakeCommands')
            # TODO: lookup path to ninja
            ETree.SubElement(make_commands, 'Build', {'command': '/usr/bin/ninja -v ' + self.meson.backend.get_target(target['name'])})
            ETree.SubElement(make_commands, 'CompileFile', {'command': '/usr/bin/ninja -v ' + self.meson.backend.get_target(target['name'])})
            ETree.SubElement(make_commands, 'Clean', {'command': '/usr/bin/ninja -v clean'})
            ETree.SubElement(make_commands, 'DistClean', {'command': '/usr/bin/ninja -v clean'})

        for target in self.meson.get_targets():
            target_files = self.meson.get_target_files(target)
            for target_file in target_files:
                unit = ETree.SubElement(project, 'Unit', {'filename': os.path.join(self.source_dir, target_file)})
                ETree.SubElement(unit, 'Option', {'target': target['name']})

                base = os.path.splitext(os.path.basename(target_file))[0]
                header_exts = ('h', 'hpp')
                for ext in header_exts:
                    header_file = os.path.abspath(
                        os.path.join(self.source_dir, os.path.dirname(target_file), os.path.join(base + '.' + ext)))
                    if os.path.exists(header_file):
                        unit = ETree.SubElement(project, 'Unit', {'filename': header_file})
                        ETree.SubElement(unit, 'Option', {'target': target['name']})

        for file in self.meson.get_buildsystem_files():
            unit = ETree.SubElement(project, 'Unit', {'filename': os.path.join(self.source_dir, file)})
            ETree.SubElement(unit, 'Option', {'virtualFolder': os.path.join('Meson Files', os.path.dirname(file))})

        project_file = os.path.join(self.build_dir, self.meson.get_project_info()['name'] + '.cbp')
        tree.write(project_file, 'unicode', True)

    def gen_make_project(self):
        # CLion requires a CMakeFiles directory at root of build directory
        root_cmakefiles_dir = os.path.join(self.build_dir, 'CMakeFiles')
        if not os.path.exists(root_cmakefiles_dir):
            os.mkdir(root_cmakefiles_dir)

        version_cmakefiles_dir = os.path.join(root_cmakefiles_dir, '.'.join(map(str, self.version)))
        if not os.path.exists(version_cmakefiles_dir):
            os.mkdir(version_cmakefiles_dir)
        with open(os.path.join(version_cmakefiles_dir, 'CMakeCCompiler.cmake'), 'w') as file:
            file.write('set(CMAKE_C_COMPILER "/usr/bin/cc")')
        with open(os.path.join(version_cmakefiles_dir, 'CMakeCXXCompiler.cmake'), 'w') as file:
            file.write('set(CMAKE_CXX_COMPILER "/usr/bin/c++")')

        # CLion requires that Makefile.cmake exists
        with open(os.path.join(root_cmakefiles_dir, 'Makefile.cmake'), 'w') as file:
            file.write('')

        # CLion fetches target directories from TargetDirectories.txt
        with open(os.path.join(root_cmakefiles_dir, 'TargetDirectories.txt'), 'w') as target_dir_file:
            targets = self.meson.get_targets()

            for target in targets:
                # All directories under the build directory should have a CMakeFiles directory
                cmakefiles_dir = os.path.join(self.build_dir, os.path.split(target['filename'])[0], 'CMakeFiles')
                Path(cmakefiles_dir).mkdir(parents=True, exist_ok=True)

                # CLion fetches target name from TARGET_NAME.dir directories
                target_path = os.path.join(self.build_dir, os.path.split(target['filename'])[0], 'CMakeFiles',
                                           target['name'] + '.dir')
                target_dir_file.write(target_path + '\n')
                Path(target_path).mkdir(exist_ok=True)

                # CLion requires that TARGET_PATH/DependInfo.cmake exists
                with open(os.path.join(target_path, 'DependInfo.cmake'), 'w') as depend_file:
                    depend_file.write('')

                # CLion fetches target name from TARGET_PATH/build.make
                with open(os.path.join(target_path, 'build.make'), 'w') as build_file:
                    build_file.write('%s: %s' % (os.path.join(target_path, 'build'), os.path.join(self.meson.build_dir, target['filename'])))

                with open(os.path.join(target_path, 'flags.make'), 'w') as flags_file:
                    compiler = self.meson.get_compiler(target)
                    if compiler:
                        if compiler.endswith('++'):
                            prefix = 'CXX'
                        else:
                            prefix = 'CC'
                        flags_file.write('%s_FLAGS = %s\n' % (prefix, ' '.join(self.meson.get_flags(target))))
                        flags_file.write('%s_DEFINES = %s\n' % (prefix, ' '.join(self.meson.get_defines(target))))
                        flags_file.write('%s_INCLUDES = %s\n' % (prefix, ' '.join(
                            ['-I' + inc_dir for inc_dir in self.meson.get_include_directories(target, False)])))


class Meson:
    """
    Base class that handles data fetching and setting options for Meson.
    """

    def __init__(self, path='meson'):
        self.path = path
        self.backend = None
        self.build_dir = None
        self.source_dir = None
        self.build_type = None
        self.cross_file = None

        # Cache
        self.c_targets = None
        self.c_target_files = {}
        self.c_buildsystem_files = None
        self.c_project_info = None
        self.c_compile_commands = None
        self.c_compile_commands_target = {}
        self.c_default_inc_dirs = {}

    def log(self, msg):
        if isinstance(msg, Exception):
            self.logger.info(msg, exc_info=msg)
        else:
            self.logger.info(msg)

    def call(self, args):
        child = Popen([self.path] + args, stdout=PIPE)
        output = child.communicate()[0]
        if child.returncode != 0:
            print(output.decode("utf-8"))
            return ''
        return output

    def set_backend(self, backend):
        if backend == 'ninja':
            self.backend = NinjaBackend(self)
        else:
            raise Exception('Backend not supported: ' + backend)

    def setup(self):
        return self.backend.setup()

    def build(self, target):
        return self.backend.build(target)

    def get_targets(self):
        if self.c_targets:
            return self.c_targets

        output = self.call(['introspect', '--targets', self.build_dir])
        self.c_targets = json.loads(output)
        return self.c_targets

    def get_target_files(self, target):
        id = target['id']
        if id == 'all':
            return []
        if id in self.c_target_files:
            return self.c_target_files[id]
        output = self.call(['introspect', '--target-files', id, self.build_dir])

        self.log('(target files) "%s"' % output)
        # Workaround https://github.com/mesonbuild/meson/issues/2783
        if output == '':
            return []

        self.c_target_files[id] = json.loads(output)
        return self.c_target_files[id]

    def get_buildsystem_files(self):
        if self.c_buildsystem_files:
            return self.c_buildsystem_files
        output = self.call(['introspect', '--buildsystem-files', self.build_dir])
        self.log('(buildsystem files) "%s"' % output)
        self.c_buildsystem_files = json.loads(output)
        return self.c_buildsystem_files

    def get_project_info(self):
        if self.c_project_info:
            return self.c_project_info
        output = self.call(['introspect', '--projectinfo', self.build_dir])
        self.log('(project info) "%s"' % output)
        self.c_project_info = json.loads(output)
        return self.c_project_info

    def get_compile_commands(self, target):
        id = target['id']
        if id in self.c_compile_commands_target:
            return self.c_compile_commands_target[id]

        if not self.c_compile_commands:
            compile_commands_file = os.path.join(self.build_dir, 'compile_commands.json')
            if not os.path.exists(compile_commands_file):
                Exception('No compile_commands.json in build dir')
            json_data = open(compile_commands_file).read()
            self.c_compile_commands = json.loads(json_data)

        # Only way to identify target compiler commands from compile_commands.json
        # is by using a file from the wanted target
        if len(self.get_target_files(target)) == 0:
            return []
        target_file = os.path.relpath(os.path.join(self.source_dir, self.get_target_files(target)[0]), self.build_dir)
        self.c_compile_commands_target[id] = next((cmd for cmd in self.c_compile_commands if cmd['file'] == target_file), None)
        return self.c_compile_commands_target[id]

    def get_compiler(self, target=None):
        if not target:
            target = self.get_targets()[0]

        compile_commands = self.get_compile_commands(target)
        if not compile_commands:
            return ''

        return compile_commands['command'].split()[0]

    def get_flags(self, target):
        compile_commands = self.get_compile_commands(target)
        if not compile_commands:
            return []

        args = compile_commands['command'].split()[1:]
        return [arg for arg in args if not arg.startswith(('-D', '-I'))]

    def get_defines(self, target):
        compile_commands = self.get_compile_commands(target)
        if not compile_commands:
            return []

        args = compile_commands['command'].split()
        return [arg for arg in args if arg.startswith('-D')]

    def get_include_directories(self, target=None, def_inc=True):
        if not target:
            target = self.get_targets()[0]

        compile_commands = self.get_compile_commands(target)
        if not compile_commands:
            return []

        if def_inc:
            def_inc_dirs = self.get_default_include_directories(target)
        else:
            def_inc_dirs = []
        args = compile_commands['command'].split()
        return [os.path.abspath(os.path.join(self.build_dir, arg[2:])) for arg in args if
                arg.startswith('-I')] + def_inc_dirs

    def get_default_include_directories(self, target=None):
        compiler = self.get_compiler(target)
        if not compiler:
            return []

        if compiler.endswith('++'):
            lang = 'c++'
        else:
            lang = 'c'

        if lang in self.c_default_inc_dirs:
            return self.c_default_inc_dirs[lang]

        output = Popen([compiler, '-x' + lang, '-E', '-v', '-'], stdin=DEVNULL, stdout=DEVNULL, stderr=PIPE)
        stderr = output.stderr.read().decode()
        start = False
        paths = []
        for line in stderr.split('\n'):
            if not start:
                if line == '#include <...> search starts here:':
                    start = True
            elif start:
                if line == 'End of search list.':
                    break
                else:
                    paths.append(os.path.abspath(line[1:]))

        self.c_default_inc_dirs[lang] = paths
        return self.c_default_inc_dirs[lang]

    def get_options(self):
        meson_options = []

        if self.cross_file:
            meson_options + ['--cross-file', self.cross_file]

        return meson_options


class NinjaBackend:
    """
    Class that handles interaction with Ninja.
    """

    def __init__(self, meson, path='ninja'):
        self.meson = meson
        self.path = path

    def call(self, args):
        child = Popen([self.path] + args, stdout=PIPE)
        output = child.communicate()[0]
        if child.returncode != 0:
            print(output.decode("utf-8"))
            return ''
        return output

    def setup(self):
        ninja_file = os.path.join(self.meson.build_dir, 'build.ninja')
        if os.path.exists(ninja_file):
            return self.reconfigure()

        meson_file = os.path.join(self.meson.source_dir, 'meson.build')
        if not os.path.exists(meson_file):
            print('No meson.build in source directory! ' + str(argv) + os.getcwd())
            return False

        self.meson.call(['setup'] + self.meson.get_options() + [self.meson.source_dir, self.meson.build_dir])

        return True

    def reconfigure(self):
        return self.call(['-C', self.meson.build_dir, 'reconfigure']) != ''

    def build(self, target):
        self.call(['-C', self.meson.build_dir, self.get_target(target)])

    def get_target(self, target_name):
        target = next((t for t in self.meson.get_targets() if t['name'] == target_name), None)
        if target:
            return target['filename']

        return target_name


class CommandToolWrapper:
    """
    Class that emulates CMake Command-Line Tool Mode.
    """

    def __init__(self, cmake):
        self.cmake = cmake

    def list_cmds(self):
        print('CMake Error: cmake version ' + '.'.join(map(str, self.cmake.version)))
        print('Usage: meson-cmake-wrapper -E <command> [arguments...]')
        print('Available commands:')
        print('  capabilities              - Report capabilities built into cmake in JSON format')
        print('  chdir dir cmd [args...]   - run command in a given directory')
        print('  compare_files file1 file2 - check if file1 is same as file2')
        print('  copy <file>... destination  - copy files to destination (either file or directory)')
        print('  copy_directory <dir>... destination   - copy content of <dir>... directories to \'destination\' directory')
        print('  copy_if_different <file>... destination  - copy files if it has changed')
        print('  echo [<string>...]        - displays arguments as text')
        print('  echo_append [<string>...] - displays arguments as text but no new line')
        print('  env [--unset=NAME]... [NAME=VALUE]... COMMAND [ARG]...')
        print('                            - run command in a modified environment')
        print('  environment               - display the current environment')
        print('  make_directory <dir>...   - create parent and <dir> directories')
        print('  md5sum <file>...          - create MD5 checksum of files')
        print('  sha1sum <file>...         - create SHA1 checksum of files')
        print('  sha224sum <file>...       - create SHA224 checksum of files')
        print('  sha256sum <file>...       - create SHA256 checksum of files')
        print('  sha384sum <file>...       - create SHA384 checksum of files')
        print('  sha512sum <file>...       - create SHA512 checksum of files')
        print('  remove [-f] <file>...     - remove the file(s), use -f to force it')
        print('  remove_directory dir      - remove a directory and its contents')
        print('  rename oldname newname    - rename a file or directory (on one volume)')
        print('  server                    - start cmake in server mode')
        print('  sleep <number>...         - sleep for given number of seconds')
        print('  tar [cxt][vf][zjJ] file.tar [file/dir1 file/dir2 ...]')
        print('                            - create or extract a tar or zip archive')
        print('  time command [args...]    - run command and return elapsed time')
        print('  touch file                - touch a file.')
        print('  touch_nocreate file       - touch a file but do not create it.')
        print('Available on UNIX only:')
        print('  create_symlink old new    - create a symbolic link new -> old')

    def run(self, args):
        if not hasattr(self, args[0] + '_cmd'):
            self.list_cmds()
            exit(1)
        getattr(self, args[0] + '_cmd')(args[1:])

    def capabilities_cmd(self, args):
        data = {
            'generators': [
                {
                    'extraGenerators': ['CodeBlocks'],
                    'name': 'Unix Makefiles',
                    'platformSupport': False,
                    'toolsetSupport': False
                },
                {
                    'extraGenerators': ['CodeBlocks'],
                    'name': 'Ninja',
                    'platformSupport': False,
                    'toolsetSupport': False
                }
            ],
            'serverMode': True,
            'version': {
                'isDirty': False,
                'major': self.cmake.version[0],
                'minor': self.cmake.version[1],
                'patch': self.cmake.version[2],
                'string': '.'.join(map(str, self.cmake.version)),
                'suffix': ''
            }
        }
        print(json.dumps(data))

    def chdir_cmd(self, args):
        os.chdir(args[0])
        call(args[1:])

    def compare_files_cmd(self, args):
        if filecmp.cmp(args[0], args[1]):
            exit(0)
        print('Files "%s" to "%s" are different.' % (args[0], args[1]))
        exit(1)

    def copy_cmd(self, args):
        files = args[:-1]
        dir = args[-1]
        if not os.path.exists(dir):
            os.makedirs(dir)
        for file in files:
            copy(file, dir)

    def copy_if_different_cmd(self, args):
        raise NotImplementedError()

    def copy_directory_cmd(self, args):
        cp_dirs = args[:-1]
        dir = args[-1]
        if not os.path.exists(dir):
            os.makedirs(dir)
        for cp_dir in cp_dirs:
            copytree(cp_dir, dir)

    def echo_cmd(self, args):
        print(' '.join(args))

    def echo_append_cmd(self, args):
        print(' '.join(args), end='')

    def env_cmd(self, args):
        env = dict(os.environ)
        for i in range(len(args)):
            if '=' in args[i]:
                if args[i].startswith('--unset'):
                    env.pop(args[i].splits('=')[1], None)
                else:
                    key, val = args[i].split('=')
                    env[key] = val
            else:
                cmd = args[i:]
                break
        Popen(cmd, env=env)

    def environment_cmd(self, args):
        for key, val in os.environ.items():
            print('%s=%s' % (key, val))

    def make_directory_cmd(self, args):
        for dir in args:
            os.makedirs(dir)

    def md5sum_cmd(self, args):
        crypt = hashlib.md5()
        for file in args:
            with open(file, 'rb') as f:
                crypt.update(f.read())
            print('%s %s' % (crypt.hexdigest(), file))

    def sha224sum_cmd(self, args):
        crypt = hashlib.sha224()
        for file in args:
            with open(file, 'rb') as f:
                crypt.update(f.read())

    def sha256sum_cmd(self, args):
        crypt = hashlib.sha256()
        for file in args:
            with open(file, 'rb') as f:
                crypt.update(f.read())

    def sha384sum_cmd(self, args):
        crypt = hashlib.sha384()
        for file in args:
            with open(file, 'rb') as f:
                crypt.update(f.read())

    def sha512sum_cmd(self, args):
        crypt = hashlib.md5()
        for file in args:
            with open(file, 'rb') as f:
                crypt.update(f.read())

    def remove_cmd(self, args):
        for file in args:
            if file != '-f':
                os.remove(file)

    def remove_directory_cmd(self, args):
        rmtree(args[0])

    def rename_cmd(self, args):
        os.rename(args[0], args[1])

    def server_cmd(self, args):
        self.cmake.server.run(args)

    def sleep_cmd(self, args):
        sleep(float(args[0]))

    def tar_cmd(self, args):
        raise NotImplementedError()

    def touch_cmd(self, args):
        with open(args[0], 'a'):
            os.utime(args[0])

    def touch_nocreate_cmd(self, args):
        if os.path.isfile(args[0]):
            with open(args[0], 'a'):
                os.utime(args[0])

    def create_symlink_cmd(self, args):
        os.symlink(args[0], args[1])


class ServerLogHandler(logging.Handler):
    def __init__(self, server):
        super().__init__()
        self.server = server

    def emit(self, record):
        log_entry = self.format(record)
        if self.server.conn:
            self.server.send_message(log_entry, log=False)


class ServerWrapper:
    """
    Class that emulates CMake Server Mode.
    """

    def __init__(self, cmake):
        self.cmake = cmake
        self.meson = cmake.meson
        self.logger = None
        self.pipe = None
        self.requests = []
        self.protocol_version = (1, 1)
        self.cookies = {}

    def log(self, msg):
        if not self.logger:
            return
        if isinstance(msg, Exception):
            self.logger.info(msg, exc_info=msg)
        else:
            self.logger.info(msg)

    def run(self, args):
        try:
            self.connect(args)
            self.handle_hello()
            self.handle_handshake()
            self.log('running on "%s"' % self.pipe)
            while 1:
                request = self.recv()
                if not request:
                    break

                if not hasattr(self, 'handle_' + request['type'].lower()):
                    self.log('unhandled request: "%s"' % request)
                    break
                getattr(self, 'handle_' + request['type'].lower())(request)
        except BrokenPipeError:
            self.log('lost connection to client')
        except Exception as e:
            self.log(e)
        finally:
            self.log('closing connection')
            self.cleanup()

    def connect(self, args):
        raise NotImplementedError()

    def cleanup(self):
        raise NotImplementedError()

    def read(self, size):
        raise NotImplementedError()

    def write(self, data):
        raise NotImplementedError()

    def recv(self):
        data = b''
        while True:
            if any(self.requests):
                return self.requests.pop(0)

            new_data = self.read(1024)
            if not new_data:
                return None
            data += new_data
            if data.endswith(SERVER_FOOTER):
                self.parse_recv(data)

    def send(self, response, log=True):
        if 'inReplyTo' in response:
            if response['inReplyTo'] in self.cookies:
                response['cookie'] = self.cookies[response['inReplyTo']]
            if log:
                self.log('%s (%s) "%s"' % (response['inReplyTo'], response['type'], response))
        elif log:
            self.log(response)

        response = SERVER_HEADER + json.dumps(response).encode('gbk') + SERVER_FOOTER
        self.write(response)

    def parse_recv(self, data):
        requests = data.split(SERVER_FOOTER + SERVER_HEADER)
        requests[0] = requests[0][len(SERVER_HEADER):]
        requests[-1] = requests[-1][:-len(SERVER_FOOTER)]

        for request in requests:
            request = json.loads(request)
            if 'cookie' in request:
                self.cookies[request['type']] = request['cookie']
            self.log('received (%s) "%s"' % (request['type'], request))
            self.requests.append(request)

    def send_reply(self, reply_to, log=True):
        response = {
            'inReplyTo': reply_to,
            'type': 'reply'
        }
        self.send(response, log)

    def send_message(self, msg, reply_to=None, log=True):
        response = {
            'type': 'message',
            'message': msg,
        }
        if reply_to:
            response['inReplyTo'] = reply_to

        self.send(response, log)

    def send_progress(self, reply_to, progress_cur, progress_max=1000, progress_min=0, msg='', log=True):
        response = {
            'inReplyTo': reply_to,
            'type': 'progress',
            'progressCurrent': progress_cur,
            'progressMaximum': progress_max,
            'progressMessage': progress_min,
            'progressMinimum': 0,
        }
        self.send(response, log)

    def handle_hello(self):
        response = {
            'supportedProtocolVersions': [{
                'isExperimental': True,
                'major': self.protocol_version[0],
                'minor': self.protocol_version[1]
            }],
            'type': 'hello'
        }
        self.send(response)

    def handle_handshake(self):
        request = self.recv()
        if not request:
            return
        self.cmake.set_build_dir(request['buildDirectory'])
        if 'generator' in request:
            self.cmake.set_generator(request['generator'])
        if 'sourceDirectory' in request:
            self.cmake.set_source_dir(request['sourceDirectory'])
        self.cmake.load_cache_entries()

        self.send_reply('handshake')

    def handle_configure(self, request):
        for entry in request['cacheArguments']:
            if entry.startswith('-D'):
                self.cmake.parse_cache_entry(entry)

        self.send_progress('configure', 1000, msg='Configuring')
        self.send_message('Configuring done', 'configure')
        self.send_reply('configure')

    def handle_compute(self, request):
        self.cmake.generate_cmd()

        self.send_progress('compute', 1000, msg='Generating')
        self.send_message('Generating done', 'compute')
        self.send_reply('compute')

    def handle_globalsettings(self, request):
        response = {
            'inReplyTo': 'globalSettings',
            'type': 'reply',
            'capabilities': {
                'generators': [
                    {
                        'name': 'Ninja',
                        'platformSupport': False,
                        'toolsetSupport': False,
                        'extraGenerators': [
                            'CodeBlocks',
                        ]
                    },
                    {
                        'name': 'Unix Makefiles',
                        'platformSupport': False,
                        'toolsetSupport': False,
                        'extraGenerators': [
                            "CodeBlocks",
                        ],
                    },
                ],
                'serverMode': True,
                'version': {
                    'isDirty': False,
                    'major': self.cmake.version[0],
                    'minor': self.cmake.version[1],
                    'patch': self.cmake.version[2],
                    'string': '.'.join(map(str, self.cmake.version)),
                    'suffix': '',
                }
            },
            'buildDirectory': self.cmake.build_dir,
            'sourceDirectory': self.cmake.source_dir,
            'generator': self.cmake.generator,
            'checkSystemVars': False,
            'debugOutput': False,
            'extraGenerator': '',
            'trace': False,
            'traceExpand': False,
            'warnUninitialized': False,
            'warnUnused': False,
            'warnUnusedCli': True
        }
        self.send(response)

    def handle_cmakeinputs(self, request):
        response = {
            'inReplyTo': 'cmakeInputs',
            'type': 'reply',
            'buildFiles': [
                {
                    'sources': self.cmake.meson.get_buildsystem_files(),
                    'isCMake': False,
                    'isTemporary': False
                }
            ],
            'cmakeRootDirectory': '/usr/share/cmake',
            'sourceDirectory': self.cmake.source_dir,
        }
        self.send(response)

    def get_cache_entries(self):
        cache_entries = []
        for key, val in self.cmake.cache_entries.items():
            cache_entries.append({
                'key': key.upper(),
                'value': val[0],
                'type': val[1],
                'properties': {}
            })
        return cache_entries

    def handle_cache(self, request):
        response = {
            'inReplyTo': 'cache',
            'type': 'reply',
            'cache': self.get_cache_entries(),
        }
        self.send(response)

    def get_include_paths(self, target):
        include_paths = []
        for include_path in self.meson.get_include_directories(target, False):
            include_paths.append({'path': include_path, 'isSystem': False})
        for include_path in self.meson.get_default_include_directories(target):
            include_paths.append({'path': include_path, 'isSystem': True})
        return include_paths

    def get_file_groups(self, target):
        sources = []
        for target_file in self.meson.get_target_files(target):
            sources.append(os.path.relpath(target_file, os.path.dirname(target['filename'])))
        file_group = {
            'isGenerated': False,
            'sources': sources,
            'compileFlags': ' '.join(self.meson.get_flags(target)),
            'defines': [define[2:] for define in self.meson.get_defines(target)],
            'includePath': self.get_include_paths(target),
            'language': 'CXX' if self.meson.get_compiler(target).endswith('++') else 'C'
        }

        meson_group = {
            'isGenerated': False,
            'sources': ['meson.build']
        }

        return [file_group, meson_group]

    def get_project(self):
        project = {
            'name': self.meson.get_project_info()['name'],
            'buildDirectory': self.cmake.build_dir,
            'sourceDirectory': self.cmake.source_dir,
            'targets': []
        }

        type_mapper = {
            'executable': 'EXECUTABLE',
            'static library': 'STATIC_LIBRARY',
            'shared library': 'SHARED_LIBRARY',
            'custom': 'UTILITY'
        }

        for mtarget in self.meson.get_targets():
            target = {}
            target['name'] = mtarget['name']
            target['fullName'] = mtarget['name']
            target['artifacts'] = [
                os.path.join(self.meson.build_dir, mtarget['filename'])
            ]
            target['buildDirectory'] = os.path.join(self.cmake.build_dir, os.path.dirname(mtarget['filename']))
            target['sourceDirectory'] = os.path.join(self.cmake.source_dir, os.path.dirname(mtarget['filename']))
            target['type'] = type_mapper[mtarget['type']]
            target['fileGroups'] = self.get_file_groups(mtarget)
            project['targets'].append(target)
        return project

    def handle_codemodel(self, request):
        response = {
            'inReplyTo': 'codemodel',
            'type': 'reply',
            'configurations': [
                {
                    'name': self.cmake.build_type,
                    'projects': [
                        self.get_project(),
                    ]
                }
            ],
        }
        self.send(response)


class UnixSocketServer(ServerWrapper):
    def __init__(self, cmake):
        super().__init__(cmake)
        self.sock = None
        self.conn = None

    def connect(self, args):
        for arg in args:
            if arg.startswith('--pipe='):
                self.pipe = arg[7:]
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock.bind(self.pipe)
        self.sock.listen(1)

        self.conn, _ = self.sock.accept()

    def cleanup(self):
        if self.conn:
            self.conn.close()
        if self.sock:
            self.sock.close()

    def read(self, size):
        return self.conn.recv(size)

    def write(self, data):
        self.conn.sendall(data)


class NamedPipeServer(ServerWrapper):
    def __init__(self, cmake):
        super().__init__(cmake)

    def connect(self, args):
        raise NotImplementedError()

    def cleanup(self):
        raise NotImplementedError()

    def read(self, size):
        raise NotImplementedError()

    def write(self, data):
        raise NotImplementedError()


CMakeWrapper().run(argv)
